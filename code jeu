import tkinter as tk
import random
import tkinter.messagebox as messagebox
import pickle
# Définition des mots possibles
liste_mots = ["python", "ordinateur", "programmation", "algorithme", "variable"]

# Sélection d'un mot au hasard
mot_choisi = random.choice(liste_mots)

# Initialisation des variables
lettres_trouvees = []
lettres_fausses = []
nb_coups = 7
scores=[]

#propose au joueur de continuer a jouer ou arreter
def fin_partie():
    global mot_choisi, lettres_trouvees, lettres_fausses, nb_coups
    if nb_coups == 0:
        messagebox.showinfo("Fin de partie", "Perdu : le mot était " + mot_choisi)
    else:
        messagebox.showinfo("Fin de partie", "Gagné !")
    if messagebox.askyesno("Nouvelle partie", "Voulez-vous jouer une nouvelle partie ?"):
    # Nouvelle partie
        lettres_trouvees = []
        lettres_fausses = []
        nb_coups = 7
        mot_choisi = random.choice(liste_mots)
        label_mot.config(text=" _" * len(mot_choisi))
        label_lettres_fausses.config(text="")
        # Effacer l'état du pendu
        dessin.delete("all")
        affiche_pendu(nb_coups)
        label_resultat.config(text="")
        for bouton in liste_boutons:
            bouton.config(state=tk.NORMAL)
    else:
    # Sauvegarde du score
        score = nb_coups
        sauvegarder_score(score, nb_coups)
    # Quitte le programme
        fenetre.quit()


#initialisation de la fonction sauvegarder score 
def sauvegarder_score(score, nb_coups):
    try:
        with open('scores.pickle', 'wb') as f:
            scores = pickle.load(f)
    except:
        scores = []
        
    scores.append((nb_coups))
    with open('scores.pickle', 'wb') as f:
        pickle.dump(scores, f)


#lire les scores 

#afficher scores 
# Fonction pour afficher les scores
def afficher_scores(score):
    if isinstance(score, (list, tuple)) and len(score) == 2:
        message = "Score: {} - Coups restants: {}\n".format(score[0], score[1])
    else:
        message = "Score invalide\n"
    print(message)


# afficher l'état du pendu
def affiche_pendu(nb_coups):
    if nb_coups == 7:
        dessin.create_line(50,400,450,400,fill='black', width=5)
        dessin.create_line(100,400,100,100,fill='black', width=5)
        dessin.create_line(100,150,150,100,fill='black', width=5)
        dessin.create_line(98,100,300,100,fill='black', width=5)
        dessin.create_line(300,100,300,150,fill='black', width=5)
    elif nb_coups == 6:
        dessin.create_oval(270,150,330,210, fill='red', width=5)
    elif nb_coups == 5:   
        dessin.create_line(300,210,300,300, fill='black', width=5)
    elif nb_coups == 4:
        dessin.create_line(300,230,260,220, fill='black', width=5)
    elif nb_coups == 3:
        dessin.create_line(300,230,340,220, fill='black', width=5)
    elif nb_coups == 2:
        dessin.create_line(300,300,260,320, fill='black', width=5)
    elif nb_coups == 1:
        dessin.create_line(300,300,340,320, fill='black', width=5)
    else:
        dessin.create_rectangle(0,0,500,500, fill='white')
        dessin.create_oval(50,50,450,450, fill='red', width=5)
        dessin.create_oval(100,150,200,250, fill='black', width=5)
        dessin.create_oval(300,150,400,250, fill='black', width=5)
        dessin.create_line(150,380,250,280, fill='black' ,width=30, capstyle='round')
        dessin.create_line(250,280,350,380, fill='black', width=30, capstyle='round')
    # Affichage des lettres fausses
    label_lettres_fausses.config(text="Lettres fausses : " + ", ".join(lettres_fausses))
    # Affichage du nombre de coups restants
    label_nb_coups.config(text="Coups restants : " + str(nb_coups))

# Fonction appelée lorsque l'utilisateur clique sur une lettre
def lettre_cliquee(lettre):
    global nb_coups, lettres_trouvees, lettres_fausses, mot_choisi, label_mot
    if lettre in mot_choisi:
        lettres_trouvees.append(lettre)
    else:
        lettres_fausses.append(lettre)
        nb_coups-= 1
        affiche_pendu(nb_coups)
    # Affichage du mot masqué
    mot_masque = ""
    for lettre_mot in mot_choisi:
        if lettre_mot in lettres_trouvees:
            mot_masque += lettre_mot
        else:
            mot_masque += "_ "
    label_mot.config(text=mot_masque)
    # Vérification de la fin de partie
    if nb_coups==0:
        fin_partie()
    if "_" not in label_mot.cget("text"):
        fin_partie()



# creation de la fenêtre
fenetre = tk.Tk()
fenetre.title("Jeu du pendu")

# canvas pour dessiner le pendu
canvas = tk.Canvas(fenetre, width=200, height=200)
canvas.pack()
dessin=tk.Canvas(fenetre, bg="ivory", width=500, height=500)
#button=tk.Button(fenetre, text="Aide",command=aide)
dessin.pack(side='top')
#button.pack(side='bottom')


# Bouton pour afficher les scores
bouton_scores = tk.Button(fenetre, text="Scores", command=afficher_scores)
bouton_scores.pack()

# afficher le mot masqué
label_mot = tk.Label(fenetre, text=" _" * len(mot_choisi))
label_mot.pack()

# Création des boutons pour les lettres de l'alphabet
liste_boutons = []
for lettre in "abcdefghijklmnopqrstuvwxyz":
    bouton = tk.Button(fenetre, text=lettre, command=lambda lettre=lettre: lettre_cliquee(lettre))
    bouton.pack(side=tk.LEFT)
    liste_boutons.append(bouton)

# afficher les lettres fausses
label_lettres_fausses = tk.Label(fenetre, text="")
label_lettres_fausses.pack()

# afficher le nombre de coups restants
label_nb_coups = tk.Label(fenetre, text="Coups restants : " + str(nb_coups))
label_nb_coups.pack()

# afficher le résultat de la partie
label_resultat = tk.Label(fenetre, text="")
label_resultat.pack()



# afficher le pendu
label_pendu = tk.Label(fenetre, text="")
label_pendu.pack()

# demarrage programme
fenetre.mainloop()