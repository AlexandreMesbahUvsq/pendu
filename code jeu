import tkinter as tk
import random
import tkinter.messagebox as messagebox
import pickle
# Définition des mots possibles
liste_mots = ["python", "ordinateur", "programmation", "algorithme", "variable"]

# Sélection d'un mot au hasard
mot_choisi = random.choice(liste_mots)

# Initialisation des variables
lettres_trouvees = []
lettres_fausses = []
nb_coups = 7

#propose au joueur de continuer a jouer ou arreter
def fin_partie():
    global mot_choisi, lettres_trouvees, lettres_fausses, nb_coups
    
    if nb_coups == 0:
        messagebox.showinfo("Fin de partie", "Perdu : le mot était " + mot_choisi)
    else:
        messagebox.showinfo("Fin de partie", "Gagné !")
        
    if messagebox.askyesno("Nouvelle partie", "Voulez-vous jouer une nouvelle partie ?"):
        # Nouvelle partie
        lettres_trouvees = []
        lettres_fausses = []
        nb_coups = 7
        mot_choisi = random.choice(liste_mots)
        label_mot.config(text=" _" * len(mot_choisi))
        label_lettres_fausses.config(text="")
        affiche_pendu(nb_coups)
        label_resultat.config(text="")
        for bouton in liste_boutons:
            bouton.config(state=tk.NORMAL)
    else:
        # Sauvegarde du score
        score = len(lettres_trouvees)
        sauvegarder_score(score, nb_coups)
        # Quitte le programme
        fenetre.quit()


#initialisation de la fonction sauvegarder score 
def sauvegarder_score(score, nb_coups):
    # On commence par charger les scores précédents, s'ils existent
    try:
        with open("scores.pickle", "rb") as f:
            scores_precedents = pickle.load(f)
    except:
        scores_precedents = {}
    # On ajoute le nouveau score
    scores_precedents[score] = nb_coups
    # On sauvegarde les scores
    with open("scores.pickle", "wb") as f:
        pickle.dump(scores_precedents, f)

#lire les scores 
def lire_scores():
    try:
        with open("scores.pickle", "rb") as f:
            scores = pickle.load(f)
    except:
        scores = {}
    return scores
#afficher scores 
def afficher_scores():
    fenetre_scores = Tk()
    fenetre_scores.title("Scores")
    scores = lire_scores()
    if len(scores) == 0:
        messagebox.showinfo("Scores", "Aucun score enregistré.")
    else:
        texte_scores = "Scores précédents :\n\n"
        for score, nb_coups in scores.items():
            texte_scores += "- Score : {} - Nombre de coups : {}\n".format(score, nb_coups)
        messagebox.showinfo("Scores", texte_scores)

# afficher l'état du pendu
def affiche_pendu(nb_coups):
    if nb_coups == 7:
        pendu = """
              _____
             |     |
             |     
             |     
             |    
             |    
             |___
        """
    elif nb_coups == 6:
        pendu = """
              _____
             |     |
             |     O
             |     
             |    
             |    
             |___
        """
    elif nb_coups == 5:
        pendu = """
              _____
             |     |
             |     O
             |     |
             |     |
             |    
             |___
        """
    elif nb_coups == 4:
        pendu = """
              _____
             |     |
             |     O
             |    /|
             |     |
             |    
             |___
        """
    elif nb_coups == 3:
        pendu = """
              _____
             |     |
             |     O
             |    /|\\
             |     |
             |    
             |___
        """
    elif nb_coups == 2:
        pendu = """
              _____
             |     |
             |     O
             |    /|\\
             |     |
             |    / 
             |___
        """
    else:
        pendu = """
              _____
             |     |
             |     O
             |    /|\\
             |     |
             |    / \\
             |___
        """
    label_pendu.config(text=pendu)
    # Affichage des lettres fausses
    label_lettres_fausses.config(text="Lettres fausses : " + ", ".join(lettres_fausses))
    # Affichage du nombre de coups restants
    label_nb_coups.config(text="Coups restants : " + str(nb_coups))

# Fonction appelée lorsque l'utilisateur clique sur une lettre
def lettre_cliquee(lettre):
    global nb_coups, lettres_trouvees, lettres_fausses, mot_choisi, label_mot
    if lettre in mot_choisi:
        lettres_trouvees.append(lettre)
    else:
        lettres_fausses.append(lettre)
        nb_coups-= 1
        affiche_pendu(nb_coups)
    # Affichage du mot masqué
    mot_masque = ""
    for lettre_mot in mot_choisi:
        if lettre_mot in lettres_trouvees:
            mot_masque += lettre_mot
        else:
            mot_masque += "_ "
    label_mot.config(text=mot_masque)
    # Vérification de la fin de partie
    if nb_coups==0:
        fin_partie()
    if "_" not in label_mot.cget("text"):
        fin_partie()



# creation de la fenêtre
fenetre = tk.Tk()
fenetre.title("Jeu du pendu")

# canvas pour dessiner le pendu
canvas = tk.Canvas(fenetre, width=200, height=200)
canvas.pack()

# afficher le mot masqué
label_mot = tk.Label(fenetre, text=" _" * len(mot_choisi))
label_mot.pack()

# Création des boutons pour les lettres de l'alphabet
liste_boutons = []
for lettre in "abcdefghijklmnopqrstuvwxyz":
    bouton = tk.Button(fenetre, text=lettre, command=lambda lettre=lettre: lettre_cliquee(lettre))
    bouton.pack(side=tk.LEFT)
    liste_boutons.append(bouton)

# afficher les lettres fausses
label_lettres_fausses = tk.Label(fenetre, text="")
label_lettres_fausses.pack()

# afficher le nombre de coups restants
label_nb_coups = tk.Label(fenetre, text="Coups restants : " + str(nb_coups))
label_nb_coups.pack()

# afficher le résultat de la partie
label_resultat = tk.Label(fenetre, text="")
label_resultat.pack()



# afficher le pendu
label_pendu = tk.Label(fenetre, text="")
label_pendu.pack()

# demarrage programme
fenetre.mainloop()